// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package api

import (
	"encoding/json"
	"errors"

	"github.com/oapi-codegen/runtime"
)

// Defines values for ClientStatus.
const (
	ClientStatusConnected ClientStatus = 5
	ClientStatusGoal      ClientStatus = 30
	ClientStatusPlaying   ClientStatus = 20
	ClientStatusReady     ClientStatus = 10
	ClientStatusUnknown   ClientStatus = 0
)

// Defines values for CommandKeys.
const (
	CommandKeyBounce            CommandKeys = "Bounce"
	CommandKeyBounced           CommandKeys = "Bounced"
	CommandKeyConnect           CommandKeys = "Connect"
	CommandKeyConnectUpdate     CommandKeys = "ConnectUpdate"
	CommandKeyConnected         CommandKeys = "Connected"
	CommandKeyConnectionRefused CommandKeys = "ConnectionRefused"
	CommandKeyDataPackage       CommandKeys = "DataPackage"
	CommandKeyGet               CommandKeys = "Get"
	CommandKeyGetDataPackage    CommandKeys = "GetDataPackage"
	CommandKeyInvalidPacket     CommandKeys = "InvalidPacket"
	CommandKeyLocationChecks    CommandKeys = "LocationChecks"
	CommandKeyLocationInfo      CommandKeys = "LocationInfo"
	CommandKeyLocationScouts    CommandKeys = "LocationScouts"
	CommandKeyPrintJSON         CommandKeys = "PrintJSON"
	CommandKeyReceivedItems     CommandKeys = "ReceivedItems"
	CommandKeyRetrieved         CommandKeys = "Retrieved"
	CommandKeyRoomInfo          CommandKeys = "RoomInfo"
	CommandKeyRoomUpdate        CommandKeys = "RoomUpdate"
	CommandKeySay               CommandKeys = "Say"
	CommandKeySet               CommandKeys = "Set"
	CommandKeySetNotify         CommandKeys = "SetNotify"
	CommandKeySetReply          CommandKeys = "SetReply"
	CommandKeyStatusUpdate      CommandKeys = "StatusUpdate"
	CommandKeySync              CommandKeys = "Sync"
	CommandKeyUpdateHint        CommandKeys = "UpdateHint"
)

// Defines values for ConnectionRefusedError.
const (
	ConnectionRefusedIncompatibleVersion  ConnectionRefusedError = "IncompatibleVersion"
	ConnectionRefusedInvalidGame          ConnectionRefusedError = "InvalidGame"
	ConnectionRefusedInvalidItemsHandling ConnectionRefusedError = "InvalidItemsHandling"
	ConnectionRefusedInvalidPassword      ConnectionRefusedError = "InvalidPassword"
	ConnectionRefusedInvalidSlot          ConnectionRefusedError = "InvalidSlot"
)

// Defines values for HintStatus.
const (
	HintStatusAvoid       HintStatus = 20
	HintStatusFound       HintStatus = 0
	HintStatusNoPriority  HintStatus = 10
	HintStatusPriority    HintStatus = 30
	HintStatusUnspecified HintStatus = 1
)

// Defines values for ItemHandlingFlag.
const (
	ItemHandlingFlagNone              ItemHandlingFlag = 0
	ItemHandlingFlagOtherWorlds       ItemHandlingFlag = 1
	ItemHandlingFlagOwnWorld          ItemHandlingFlag = 2
	ItemHandlingFlagStartingInventory ItemHandlingFlag = 4
)

// Defines values for JSONMessagePartColor.
const (
	JsonMessagePartColorBlack     JSONMessagePartColor = "black"
	JsonMessagePartColorBlackBG   JSONMessagePartColor = "black_bg"
	JsonMessagePartColorBlue      JSONMessagePartColor = "blue"
	JsonMessagePartColorBlueBG    JSONMessagePartColor = "blue_bg"
	JsonMessagePartColorBold      JSONMessagePartColor = "bold"
	JsonMessagePartColorCyan      JSONMessagePartColor = "cyan"
	JsonMessagePartColorCyanBG    JSONMessagePartColor = "cyan_bg"
	JsonMessagePartColorGreen     JSONMessagePartColor = "green"
	JsonMessagePartColorGreenBG   JSONMessagePartColor = "green_bg"
	JsonMessagePartColorMagenta   JSONMessagePartColor = "magenta"
	JsonMessagePartColorMagentaBG JSONMessagePartColor = "magenta_bg"
	JsonMessagePartColorRed       JSONMessagePartColor = "red"
	JsonMessagePartColorRedBG     JSONMessagePartColor = "red_bg"
	JsonMessagePartColorUnderline JSONMessagePartColor = "underline"
	JsonMessagePartColorWhite     JSONMessagePartColor = "white"
	JsonMessagePartColorWhiteBG   JSONMessagePartColor = "white_bg"
	JsonMessagePartColorYellow    JSONMessagePartColor = "yellow"
	JsonMessagePartColorYellowBG  JSONMessagePartColor = "yellow_bg"
)

// Defines values for JSONMessagePartType.
const (
	JsonMessagePartTypeColor        JSONMessagePartType = "color"
	JsonMessagePartTypeEntranceName JSONMessagePartType = "entrance_name"
	JsonMessagePartTypeItemID       JSONMessagePartType = "item_id"
	JsonMessagePartTypeItemName     JSONMessagePartType = "item_name"
	JsonMessagePartTypeLocationID   JSONMessagePartType = "location_id"
	JsonMessagePartTypeLocationName JSONMessagePartType = "location_name"
	JsonMessagePartTypePlayerID     JSONMessagePartType = "player_id"
	JsonMessagePartTypePlayerName   JSONMessagePartType = "player_name"
	JsonMessagePartTypeText         JSONMessagePartType = "text"
)

// Defines values for NetworkItemFlags.
const (
	NetworkItemFlagEmpty              NetworkItemFlags = 0
	NetworkItemFlagImportant          NetworkItemFlags = 2
	NetworkItemFlagLogicalAdvancement NetworkItemFlags = 1
	NetworkItemFlagTrap               NetworkItemFlags = 4
)

// Defines values for OperationKey.
const (
	OperationKeyAdd        OperationKey = "add"
	OperationKeyAnd        OperationKey = "and"
	OperationKeyCeil       OperationKey = "ceil"
	OperationKeyDefault    OperationKey = "default"
	OperationKeyFloor      OperationKey = "floor"
	OperationKeyLeftShift  OperationKey = "left_shift"
	OperationKeyMax        OperationKey = "max"
	OperationKeyMin        OperationKey = "min"
	OperationKeyMod        OperationKey = "mod"
	OperationKeyMul        OperationKey = "mul"
	OperationKeyOr         OperationKey = "or"
	OperationKeyPop        OperationKey = "pop"
	OperationKeyPow        OperationKey = "pow"
	OperationKeyRemove     OperationKey = "remove"
	OperationKeyReplace    OperationKey = "replace"
	OperationKeyRightShift OperationKey = "right_shift"
	OperationKeyUpdate     OperationKey = "update"
	OperationKeyXor        OperationKey = "xor"
)

// Defines values for PacketProblemType.
const (
	PacketProblemTypeArguments PacketProblemType = "arguments"
	PacketProblemTypeCmd       PacketProblemType = "cmd"
)

// Defines values for Permission.
const (
	PermissionAuto        Permission = 6
	PermissionAutoEnabled Permission = 7
	PermissionDisabled    Permission = 0
	PermissionEnabled     Permission = 1
	PermissionGoal        Permission = 2
)

// Defines values for PrintJsonType.
const (
	PrintJsonTypeAdminCommandResult PrintJsonType = "AdminCommandResult"
	PrintJsonTypeChat               PrintJsonType = "Chat"
	PrintJsonTypeCollect            PrintJsonType = "Collect"
	PrintJsonTypeCommandResult      PrintJsonType = "CommandResult"
	PrintJsonTypeCountdown          PrintJsonType = "Countdown"
	PrintJsonTypeGoal               PrintJsonType = "Goal"
	PrintJsonTypeHint               PrintJsonType = "Hint"
	PrintJsonTypeItemCheat          PrintJsonType = "ItemCheat"
	PrintJsonTypeItemSend           PrintJsonType = "ItemSend"
	PrintJsonTypeJoin               PrintJsonType = "Join"
	PrintJsonTypePart               PrintJsonType = "Part"
	PrintJsonTypeRelease            PrintJsonType = "Release"
	PrintJsonTypeServerChat         PrintJsonType = "ServerChat"
	PrintJsonTypeTagsChanged        PrintJsonType = "TagsChanged"
	PrintJsonTypeTutorial           PrintJsonType = "Tutorial"
)

// Defines values for SlotType.
const (
	SlotTypeGroup     SlotType = 2
	SlotTypePlayer    SlotType = 1
	SlotTypeSpectator SlotType = 0
)

// Defines values for Tags.
const (
	TagValueAP        Tags = "AP"
	TagValueDeathLink Tags = "DeathLink"
	TagValueHintGame  Tags = "HintGame"
	TagValueTextOnly  Tags = "TextOnly"
	TagValueTracker   Tags = "Tracker"
)

// Bounce Send this message to the server, tell it which clients should receive
// the message and the server will forward the message to all those targets
// to which any one requirement applies.
type Bounce struct {
	Cmd string `json:"cmd"`

	// Data The data in the Bounce package copied
	Data map[string]interface{} `json:"data"`

	// Games Optional. Game names this message is targeting
	Games *[]string `json:"games,omitempty"`

	// Slots Optional. Player slot IDs that this message is targeting
	Slots *[]string `json:"slots,omitempty"`

	// Tags Optional. Client Tags this message is targeting
	Tags *[]Tags `json:"tags,omitempty"`
}

// Bounced Sent to clients after a client requested this message be sent to them, more info in the Bounce package.
type Bounced struct {
	Cmd string `json:"cmd"`

	// Data The data in the Bounce package copied
	Data map[string]interface{} `json:"data"`

	// Games Optional. Game names this message is targeting
	Games *[]string `json:"games,omitempty"`

	// Slots Optional. Player slot IDs that this message is targeting
	Slots *[]string `json:"slots,omitempty"`

	// Tags Optional. Client Tags this message is targeting
	Tags *[]Tags `json:"tags,omitempty"`
}

// ClientStatus An enumeration containing the possible client states that may be used to inform the server in StatusUpdate.
// The MultiServer automatically sets the client state to ClientStatus.CLIENT_CONNECTED on the first active connection to a slot.
type ClientStatus int

// Command defines model for Command.
type Command struct {
	union json.RawMessage
}

// CommandKeys they value that can be passed in the cmd part of the command
type CommandKeys string

// Commands defines model for Commands.
type Commands = []Command

// Connect Sent by the client to initiate a connection to an Archipelago game session.
type Connect struct {
	Cmd string `json:"cmd"`

	// Game The name of the game the client is playing. Example: A Link to the Past
	Game string `json:"game"`

	// ItemsHandling Flags configuring which items should be sent by the server. Read below for individual flags.
	ItemsHandling ItemHandlingFlag `json:"items_handling"`

	// Name The player name for this client.
	Name string `json:"name"`

	// Password If the game session requires a password, it should be passed here.
	Password string `json:"password"`

	// SlotData If true, the Connect answer will contain slot_data
	SlotData bool `json:"slot_data"`

	// Tags Denotes special features or capabilities that the sender is capable of. Tags
	Tags []Tags `json:"tags"`

	// Uuid Unique identifier for player client.
	Uuid string `json:"uuid"`

	// Version An object representing the Archipelago version this client supports.
	Version NetworkVersion `json:"version"`
}

// ConnectUpdate Update arguments from the Connect package, currently only updating tags and items_handling is supported.
type ConnectUpdate struct {
	Cmd string `json:"cmd"`

	// ItemsHandling Flags configuring which items should be sent by the server.
	ItemsHandling ItemHandlingFlag `json:"items_handling"`

	// Tags Denotes special features or capabilities that the sender is capable of. Tags
	Tags []Tags `json:"tags"`
}

// Connected Sent to clients when the connection handshake is successfully completed.
type Connected struct {
	// CheckedLocations Contains ids of all locations that have been checked. Useful for trackers, among other things. Location ids are in the range of ± 253-1.
	CheckedLocations []int  `json:"checked_locations"`
	Cmd              string `json:"cmd"`

	// HintPoints Number of hint points that the current player has.
	HintPoints int `json:"hint_points"`

	// MissingLocations Contains ids of remaining locations that need to be checked. Useful for trackers, among other things.
	MissingLocations []int `json:"missing_locations"`

	// Players List denoting other players in the multiworld, whether connected or not.
	Players []NetworkPlayer `json:"players"`

	// Slot Your slot number on your team. See NetworkPlayer for more info on the slot number.
	Slot int `json:"slot"`

	// SlotData Contains a json object for slot related data, differs per game. Empty if not required. Not present if slot_data in Connect is false.
	SlotData map[string]interface{} `json:"slot_data"`

	// SlotInfo maps each slot to a NetworkSlot information.
	SlotInfo map[int]NetworkSlot `json:"slot_info"`

	// Team Your team number. See NetworkPlayer for more info on team number.
	Team int `json:"team"`
}

// ConnectionRefused Sent to clients when the server refuses connection.
// This is sent during the initial connection handshake.
type ConnectionRefused struct {
	Cmd string `json:"cmd"`

	// Errors Optional. When provided, should contain any one of:
	// InvalidSlot, InvalidGame, IncompatibleVersion, InvalidPassword, or InvalidItemsHandling.
	Errors *[]ConnectionRefusedError `json:"errors,omitempty"`
}

// ConnectionRefusedError The potential error values that can be returned in the list of errors in a connection refused.
type ConnectionRefusedError string

// DataPackage Sent to clients to provide what is known as a 'data package' which contains
// information to enable a client to most easily communicate with the Archipelago server.
// Contents include things like location id to name mappings,
// among others; see Data Package Contents for more info.
type DataPackage struct {
	Cmd string `json:"cmd"`

	// Data The data package as a JSON object.
	Data DataPackageObject `json:"data"`
}

// DataPackageObject defines model for DataPackageObject.
type DataPackageObject struct {
	// Games Mapping of all Games and their respective data
	Games map[string]GameData `json:"games"`
}

// DataStorageOperation A DataStorageOperation manipulates or alters the value of a key in the data storage.
// If the operation transforms the value from one state to another then the current
// value of the key is used as the starting point otherwise the Set's package default
// is used if the key does not exist on the server already.
// DataStorageOperations consist of an object containing both the operation to be applied,
// provided in the form of a string, as well as the value to be used for that operation
type DataStorageOperation struct {
	// Operation the operation to be applied
	Operation interface{} `json:"operation"`

	// Value the value used by the operation. Operation key dependant.
	Value *interface{} `json:"value,omitempty"`
}

// DeathLink defines model for DeathLink.
type DeathLink struct {
	// Cause Optional. Text to explain the cause of death. When provided, or checked, this should contain the player name, ex. "Berserker was run over by a train."
	Cause *string `json:"cause,omitempty"`

	// Source Name of the player who first died. Can be a slot name, but can also be a name from within a multiplayer game.
	Source string `json:"source"`

	// Time Unix Time Stamp of time of death.
	Time float32 `json:"time"`
}

// GameData defines model for GameData.
type GameData struct {
	// Checksum A checksum hash of this game's data.
	Checksum string `json:"checksum"`

	// ItemNameToId Mapping of all item names to their respective ID.
	ItemNameToId map[string]int `json:"item_name_to_id"`

	// LocationNameToId Mapping of all location names to their respective ID.
	LocationNameToId map[string]int `json:"location_name_to_id"`
}

// Get Used to request a single or multiple values from the server's data
// storage, see the Set package for how to write values to the data storage.
// A Get package will be answered with a Retrieved package.
type Get struct {
	Cmd string `json:"cmd"`

	// Keys Keys to retrieve the values for.
	// Additional arguments sent in this package will also be added to the Retrieved package it triggers.
	//
	// Some special keys exist with specific return data, all of them have the prefix _read_, so hints_{team}_{slot} is _read_hints_{team}_{slot}.
	// - hints_{team}_{slot} | list[Hint] | All Hints belonging to the requested Player.
	// - slot_data_{slot} | dict[str, any] | slot_data belonging to the requested slot.
	// - item_name_groups_{game_name} | dict[str, list[str]] | item_name_groups belonging to the requested game.
	// - location_name_groups_{game_name} | dict[str, list[str]] | location_name_groups belonging to the requested game.
	// - client_status_{team}_{slot} | ClientStatus | The current game status of the requested player.
	// - race_mode | int | 0 if race mode is disabled, and 1 if it's enabled.
	Keys *[]string `json:"keys,omitempty"`
}

// GetDataPackage Requests the data package from the server.
// Does not require client authentication.
type GetDataPackage struct {
	Cmd string `json:"cmd"`

	// Games If specified, will only send back the specified data. Such as, ["Factorio"] -> Datapackage with only Factorio data.
	Games *[]string `json:"games,omitempty"`
}

// Hint An object representing a Hint.
type Hint struct {
	Entrance        string `json:"entrance"`
	FindingPlayer   int    `json:"finding_player"`
	Found           bool   `json:"found"`
	Item            int    `json:"item"`
	ItemFlags       int    `json:"item_flags"`
	Location        int    `json:"location"`
	ReceivingPlayer int    `json:"receiving_player"`

	// Status An enumeration containing the possible hint states.
	// Hints for items with ItemClassification.trap default to HINT_AVOID.
	// Hints created with LocationScouts, !hint_location, or similar (hinting a location) default to HINT_UNSPECIFIED.
	// Hints created with !hint or similar (hinting an item for yourself) default to HINT_PRIORITY.
	// Once a hint is collected, its' status is updated to HINT_FOUND automatically, and can no longer be changed.
	Status HintStatus `json:"status"`
}

// HintStatus An enumeration containing the possible hint states.
// Hints for items with ItemClassification.trap default to HINT_AVOID.
// Hints created with LocationScouts, !hint_location, or similar (hinting a location) default to HINT_UNSPECIFIED.
// Hints created with !hint or similar (hinting an item for yourself) default to HINT_PRIORITY.
// Once a hint is collected, its' status is updated to HINT_FOUND automatically, and can no longer be changed.
type HintStatus int

// InvalidPacket Sent to clients if the server caught a problem with a packet.
// This only occurs for errors that are explicitly checked for.
type InvalidPacket struct {
	Cmd string `json:"cmd"`

	// OriginalCmd The cmd argument of the faulty packet, will be None if the cmd failed to be parsed.
	OriginalCmd *string `json:"original_cmd,omitempty"`

	// Text A descriptive message of the problem at hand.
	Text string `json:"text"`

	// Type The PacketProblemType that was detected in the packet.
	Type PacketProblemType `json:"type"`
}

// ItemHandlingFlag defines model for ItemHandlingFlag.
type ItemHandlingFlag int

// JSONMessagePart Message nodes sent along with PrintJSON packet to be reconstructed into a legible message.
// The nodes are intended to be read in the order they are listed in the packet.
type JSONMessagePart struct {
	// Color only available if type is a color
	Color *JSONMessagePartColor `json:"color,omitempty"`

	// Flags only available if type is an item_id or item_name
	Flags *int `json:"flags,omitempty"`

	// Player only available if type is either item or location
	Player *int   `json:"player,omitempty"`
	Text   string `json:"text"`

	// Type type is used to denote the intent of the message part.
	// This can be used to indicate special information which may be rendered differently depending on client.
	// How these types are displayed in Archipelago's ALttP client is not the end-all be-all.
	// Other clients may choose to interpret and display these messages differently.
	Type JSONMessagePartType `json:"type"`
}

// JSONMessagePartColor Color is used to denote a console color to display the message part with and is only send if the type is color. This is limited to console colors due to backwards compatibility needs with games such as ALttP. Although background colors as well as foreground colors are listed, only one may be applied to a JSONMessagePart at a time.
type JSONMessagePartColor string

// JSONMessagePartType type is used to denote the intent of the message part.
// This can be used to indicate special information which may be rendered differently depending on client.
// How these types are displayed in Archipelago's ALttP client is not the end-all be-all.
// Other clients may choose to interpret and display these messages differently.
type JSONMessagePartType string

// LocationChecks Sent to server to inform it of locations that the client has checked.
// Used to inform the server of new checks that are made, as well as to sync state.
type LocationChecks struct {
	Cmd string `json:"cmd"`

	// Locations The ids of the locations checked by the client.
	// May contain any number of checks, even ones sent before;
	// duplicates do not cause issues with the Archipelago server.
	Locations []int `json:"locations"`
}

// LocationInfo Sent to clients to acknowledge a received LocationScouts packet and
// responds with the item in the location(s) being scouted.
type LocationInfo struct {
	Cmd string `json:"cmd"`

	// Locations Contains list of item(s) in the location(s) scouted
	Locations []NetworkItem `json:"locations"`
}

// LocationScouts Sent to the server to retrieve the items that are on a specified list of locations.
// The server will respond with a LocationInfo packet containing the items located in the
// scouted locations. Fully remote clients without a patch file may use this to
// "place" items onto their in-game locations, most commonly to display their
// names or item classifications before/upon pickup.
//
// LocationScouts can also be used to inform the server of
// locations the client has seen, but not checked.
// This creates a hint as if the player had run !hint_location on a location,
// but without deducting hint points. This is useful in cases where an item appears
// in the game world, such as 'ledge items' in A Link to the Past.
// To do this, set the create_as_hint parameter to a non-zero value.
type LocationScouts struct {
	Cmd string `json:"cmd"`

	// CreateAsHint If non-zero, the scouted locations get created and broadcasted as a player-visible hint.
	// If 2 only new hints are broadcast, however this does not remove them from the LocationInfo reply.
	CreateAsHint *int `json:"create_as_hint,omitempty"`

	// Locations The ids of the locations seen by the client.
	// May contain any number of locations, even ones sent before;
	// duplicates do not cause issues with the Archipelago server.
	Locations []int `json:"locations"`
}

// NetworkItem Items that are sent over the net (in packets) use the following data structure and are sent as objects:
type NetworkItem struct {
	// Flags Flags used in the NetworkItem
	Flags NetworkItemFlags `json:"flags"`

	// Item The item id of the item.
	// Item ids are only supported in the range of [-253, 253 - 1].
	// Anything ≤ 0 is reserved for Archipelago use.
	Item int `json:"item"`

	// Location The location id of the item inside the world.
	// Location ids are only supported in the range of [-253, 253 - 1].
	// Anything ≤ 0 reserved for Archipelago use.
	Location int `json:"location"`

	// Player The player slot of the world the item is located in,
	// except when inside an LocationInfo Packet then it
	// will be the slot of the player to receive the item.
	Player int `json:"player"`
}

// NetworkItemFlags Flags used in the NetworkItem
type NetworkItemFlags int

// NetworkPlayer A list of objects. Each object denotes one player.
// Each object has four fields about the player, in this order:
// team, slot, alias, and name. team and slot are ints, alias and name are strs.
//
// Each player belongs to a team and has a slot. Team numbers start at 0.
// Slot numbers are unique per team and start at 1.
// Slot number 0 refers to the Archipelago server;
// this may appear in instances where the server grants the player an item.
//
// Alias represents the player's name in current time.
// Name is the original name used when the session was generated.
// This is typically distinct in games which require baking names into ROMs or for async games.
type NetworkPlayer struct {
	// Alias represents the player's name in current time.
	Alias string `json:"alias"`

	// Name The original name used when the session was generated.
	// This is typically distinct in games which require baking names into ROMs or for async games.
	Name string `json:"name"`

	// Slot Slot numbers are unique per team and start at 1.
	// Slot number 0 refers to the Archipelago server;
	// this may appear in instances where the server grants the player an item
	Slot int `json:"slot"`

	// Team Team numbers start at 0
	Team int `json:"team"`
}

// NetworkSlot An object representing static information about a slot.
type NetworkSlot struct {
	Game string `json:"game"`

	// GroupMembers only populated if type == group
	GroupMembers []int  `json:"group_members"`
	Name         string `json:"name"`

	// Type An enum representing the nature of a slot.
	Type SlotType `json:"type"`
}

// NetworkVersion An object representing software versioning. Used in the Connect packet to allow the client to inform the server of the Archipelago version it supports.
type NetworkVersion struct {
	Build int `json:"build"`

	// Class constant string set to "Version"
	Class string `json:"class"`
	Major int    `json:"major"`
	Minor int    `json:"minor"`
}

// OperationKey The following operations can be applied to a datastorage key
type OperationKey string

// PacketProblemType defines model for PacketProblemType.
type PacketProblemType string

// Permission An enumeration containing the possible command permission, for commands that may be restricted.
type Permission int

// PrintJSON Sent to clients purely to display a message to the player.
// While various message types provide additional arguments,
// clients only need to evaluate the data argument to construct
// the human-readable message text.
// All other arguments may be ignored safely.
type PrintJSON struct {
	Cmd string `json:"cmd"`

	// Countdown Message Type: Countdown
	// Amount of seconds remaining on the countdown
	Countdown *int `json:"countdown,omitempty"`

	// Data Message Type: (all)
	// Textual content of this message
	Data []JSONMessagePart `json:"data"`

	// Found Message Type: Hint
	// Whether the location hinted for was checked
	Found *bool `json:"found,omitempty"`

	// Item Message Type: NetworkItem 	ItemSend, ItemCheat, Hint
	// Source player's ID, location ID, item ID and item flags
	Item *NetworkItem `json:"item,omitempty"`

	// Message Message Type: Chat, ServerChat
	// Original chat message without sender prefix
	Message *string `json:"message,omitempty"`

	// Receiving Message Type: ItemSend, ItemCheat, Hint
	// Destination player's ID
	Receiving *int `json:"receiving,omitempty"`

	// Slot Message Type: Join, Part, Chat, TagsChanged, Goal, Release, Collect
	// Slot of the triggering player
	Slot *int `json:"slot,omitempty"`

	// Tags Message Type: Join, TagsChanged
	// Tags of the triggering player
	Tags *[]Tags `json:"tags,omitempty"`

	// Team Message Type: Join, Part, Chat, TagsChanged, Goal, Release, Collect, ItemCheat
	// Team of the triggering player
	Team *int `json:"team,omitempty"`

	// Type Message Type: (all)
	// PrintJsonType of this message (optional)
	Type *PrintJsonType `json:"type,omitempty"`
}

// PrintJsonType PrintJsonType indicates the type of a PrintJSON packet.
// Different types can be handled differently by the client and can also contain additional arguments.
// When receiving an unknown or missing type, the data's list[JSONMessagePart] should still be displayed to the player as normal text.
type PrintJsonType string

// ReceivedItems Sent to clients when they receive an item.
type ReceivedItems struct {
	Cmd string `json:"cmd"`

	// Index The next empty slot in the list of items for the receiving client.
	Index int `json:"index"`

	// Items The items which the client is receiving.
	Items []NetworkItem `json:"items"`
}

// Retrieved Sent to clients as a response the a Get package.
//
// If a requested key was not present in the server's data, the associated value will be null.
//
// Additional arguments added to the Get package that triggered this Retrieved will also be passed along.
type Retrieved struct {
	Cmd string `json:"cmd"`

	// Keys A key-value collection containing all the values for the keys requested in the Get package.
	Keys map[string]interface{} `json:"keys"`
}

// RoomInfo Sent to clients when they connect to an Archipelago server.
type RoomInfo struct {
	Cmd string `json:"cmd"`

	// DatapackageChecksums Checksum hash of the individual games' data packages the server will send. Used by newer clients to decide which games' caches are outdated. See Data Package Contents for more information.
	DatapackageChecksums map[string]string `json:"datapackage_checksums"`

	// Games List of games present in this multiworld.
	Games []string `json:"games"`

	// GeneratorVersion Object denoting the version of Archipelago which generated the multiworld.
	GeneratorVersion NetworkVersion `json:"generator_version"`

	// HintCost The percentage of total locations that need to be checked to receive a hint from the server.
	HintCost int `json:"hint_cost"`

	// LocationCheckPoints The amount of hint points you receive per item/location check completed.
	LocationCheckPoints int `json:"location_check_points"`

	// Password Denoted whether a password is required to join this room.
	Password bool `json:"password"`

	// Permissions Mapping of permission name to Permission, keys are: "release", "collect" and "remaining".
	//
	// ## release
	// Dictates what is allowed when it comes to a player releasing their run. A release is an action which distributes the rest of the items in a player's run to those other players awaiting them.
	//     auto: Distributes a player's items to other players when they complete their goal.
	//     enabled: Denotes that players may release at any time in the game.
	//     auto-enabled: Both of the above options together.
	//     disabled: All release modes disabled.
	//     goal: Allows for manual use of release command once a player completes their goal. (Disabled until goal completion)
	//
	// ## collect
	// Dictates what is allowed when it comes to a player collecting their run. A collect is an action which sends the rest of the items in a player's run.
	//     auto: Automatically when they complete their goal.
	//     enabled: Denotes that players may !collect at any time in the game.
	//     auto-enabled: Both of the above options together.
	//     disabled: All collect modes disabled.
	//     goal: Allows for manual use of collect command once a player completes their goal. (Disabled until goal completion)
	//
	// ## remaining
	// Dictates what is allowed when it comes to a player querying the items remaining in their run.
	//     goal: Allows a player to query for items remaining in their run but only after they completed their own goal.
	//     enabled: Denotes that players may query for any items remaining in their run (even those belonging to other players).
	//     disabled: All remaining item query modes disabled.
	Permissions map[string]Permission `json:"permissions"`

	// SeedName Uniquely identifying name of this generation
	SeedName string `json:"seed_name"`

	// Tags Denotes special features or capabilities that the sender is capable of. Example: WebHost
	Tags []Tags `json:"tags"`

	// Time Unix time stamp of "now". Send for time synchronization if wanted for things like the DeathLink Bounce.
	Time float32 `json:"time"`

	// Version Object denoting the version of Archipelago which the server is running.
	Version NetworkVersion `json:"version"`
}

// RoomUpdate Sent when there is a need to update information about the present game session.
// All arguments for this packet are optional, only changes are sent.
type RoomUpdate struct {
	// CheckedLocations May be a partial update, containing new locations that were checked, especially from a coop partner in the same slot.
	CheckedLocations *[]int `json:"checked_locations,omitempty"`
	Cmd              string `json:"cmd"`

	// MissingLocations Never sent in this packet. If needed, it is the inverse of checked_locations.
	MissingLocations *map[string]interface{} `json:"missing_locations,omitempty"`

	// Players Sent in the event of an alias rename. Always sends all players, whether connected or not.
	Players *[]NetworkPlayer `json:"players,omitempty"`
}

// Say Basic chat command which sends text to the server to be distributed to other clients.
type Say struct {
	Cmd string `json:"cmd"`

	// Text Text to send to others.
	Text string `json:"text"`
}

// Set Used to write data to the server's data storage, that data can then
// be shared across worlds or just saved for later. Values for keys
// in the data storage can be retrieved with a Get package, or monitored
// with a SetNotify package. Keys that start with _read_ cannot be set.
type Set struct {
	Cmd string `json:"cmd"`

	// Default The default value to use in case the key has no value on the server.
	Default *interface{} `json:"default,omitempty"`

	// Key The key to manipulate. Can never start with "_read".
	Key *string `json:"key,omitempty"`

	// Operations Operations to apply to the value, multiple operations can be present and they will be executed in order of appearance.
	Operations *[]DataStorageOperation `json:"operations,omitempty"`

	// WantReply If true, the server will send a SetReply response back to the client.
	WantReply *bool `json:"want_reply,omitempty"`
}

// SetNotify Used to register your current session for receiving all SetReply
// packages of certain keys to allow your client to keep track of changes.
type SetNotify struct {
	Cmd string `json:"cmd"`

	// Keys Keys to receive all SetReply packages for.
	Keys *[]string `json:"keys,omitempty"`
}

// SetReply Sent to clients in response to a Set package if want_reply was set to true,
// or if the client has registered to receive updates for a certain key using
// the SetNotify package. SetReply packages are sent even if a Set package
// did not alter the value for the key.
//
// Additional arguments added to the Set package that triggered this SetReply will also be passed along.
type SetReply struct {
	Cmd string `json:"cmd"`

	// Key The key that was updated.
	Key string `json:"key"`

	// OriginalValue The value the key had before it was updated. Not present on "_read" prefixed special keys.
	OriginalValue *interface{} `json:"original_value,omitempty"`

	// Value The new value for the key.
	Value interface{} `json:"value"`
}

// SlotType An enum representing the nature of a slot.
type SlotType int

// StatusUpdate Sent to the server to update on the sender's status.
// Examples include readiness or goal completion.
// (Example: defeated Ganon in A Link to the Past)
type StatusUpdate struct {
	Cmd string `json:"cmd"`

	// Status One of Client States. Send as int. Follow the link for more information.
	Status ClientStatus `json:"status"`
}

// Sync Sent to server to request a ReceivedItems packet to synchronize items.
type Sync struct {
	Cmd string `json:"cmd"`
}

// Tags defines model for Tags.
type Tags string

// UpdateHint Sent to the server to update the status of a Hint.
// The client must be the 'receiving_player' of the Hint,
// or the update fails.
type UpdateHint struct {
	Cmd string `json:"cmd"`

	// Location The ID of the location to update the hint for. If no hint exists for this location, the packet is ignored.
	Location int `json:"location"`

	// Player The ID of the player whose location is being hinted for.
	Player int `json:"player"`

	// Status If included, sets the status of the hint to this status. Cannot set HINT_FOUND, or change the status from HINT_FOUND.
	Status *HintStatus `json:"status,omitempty"`
}

// AsRoomInfo returns the union data inside the Command as a RoomInfo
func (t Command) AsRoomInfo() (RoomInfo, error) {
	var body RoomInfo
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRoomInfo overwrites any union data inside the Command as the provided RoomInfo
func (t *Command) FromRoomInfo(v RoomInfo) error {
	v.Cmd = "RoomInfo"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRoomInfo performs a merge with any union data inside the Command, using the provided RoomInfo
func (t *Command) MergeRoomInfo(v RoomInfo) error {
	v.Cmd = "RoomInfo"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsConnectionRefused returns the union data inside the Command as a ConnectionRefused
func (t Command) AsConnectionRefused() (ConnectionRefused, error) {
	var body ConnectionRefused
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromConnectionRefused overwrites any union data inside the Command as the provided ConnectionRefused
func (t *Command) FromConnectionRefused(v ConnectionRefused) error {
	v.Cmd = "ConnectionRefused"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeConnectionRefused performs a merge with any union data inside the Command, using the provided ConnectionRefused
func (t *Command) MergeConnectionRefused(v ConnectionRefused) error {
	v.Cmd = "ConnectionRefused"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsConnected returns the union data inside the Command as a Connected
func (t Command) AsConnected() (Connected, error) {
	var body Connected
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromConnected overwrites any union data inside the Command as the provided Connected
func (t *Command) FromConnected(v Connected) error {
	v.Cmd = "Connected"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeConnected performs a merge with any union data inside the Command, using the provided Connected
func (t *Command) MergeConnected(v Connected) error {
	v.Cmd = "Connected"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsReceivedItems returns the union data inside the Command as a ReceivedItems
func (t Command) AsReceivedItems() (ReceivedItems, error) {
	var body ReceivedItems
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromReceivedItems overwrites any union data inside the Command as the provided ReceivedItems
func (t *Command) FromReceivedItems(v ReceivedItems) error {
	v.Cmd = "ReceivedItems"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeReceivedItems performs a merge with any union data inside the Command, using the provided ReceivedItems
func (t *Command) MergeReceivedItems(v ReceivedItems) error {
	v.Cmd = "ReceivedItems"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsLocationInfo returns the union data inside the Command as a LocationInfo
func (t Command) AsLocationInfo() (LocationInfo, error) {
	var body LocationInfo
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLocationInfo overwrites any union data inside the Command as the provided LocationInfo
func (t *Command) FromLocationInfo(v LocationInfo) error {
	v.Cmd = "LocationInfo"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLocationInfo performs a merge with any union data inside the Command, using the provided LocationInfo
func (t *Command) MergeLocationInfo(v LocationInfo) error {
	v.Cmd = "LocationInfo"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRoomUpdate returns the union data inside the Command as a RoomUpdate
func (t Command) AsRoomUpdate() (RoomUpdate, error) {
	var body RoomUpdate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRoomUpdate overwrites any union data inside the Command as the provided RoomUpdate
func (t *Command) FromRoomUpdate(v RoomUpdate) error {
	v.Cmd = "RoomUpdate"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRoomUpdate performs a merge with any union data inside the Command, using the provided RoomUpdate
func (t *Command) MergeRoomUpdate(v RoomUpdate) error {
	v.Cmd = "RoomUpdate"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPrintJSON returns the union data inside the Command as a PrintJSON
func (t Command) AsPrintJSON() (PrintJSON, error) {
	var body PrintJSON
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPrintJSON overwrites any union data inside the Command as the provided PrintJSON
func (t *Command) FromPrintJSON(v PrintJSON) error {
	v.Cmd = "PrintJSON"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePrintJSON performs a merge with any union data inside the Command, using the provided PrintJSON
func (t *Command) MergePrintJSON(v PrintJSON) error {
	v.Cmd = "PrintJSON"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDataPackage returns the union data inside the Command as a DataPackage
func (t Command) AsDataPackage() (DataPackage, error) {
	var body DataPackage
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDataPackage overwrites any union data inside the Command as the provided DataPackage
func (t *Command) FromDataPackage(v DataPackage) error {
	v.Cmd = "DataPackage"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDataPackage performs a merge with any union data inside the Command, using the provided DataPackage
func (t *Command) MergeDataPackage(v DataPackage) error {
	v.Cmd = "DataPackage"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBounced returns the union data inside the Command as a Bounced
func (t Command) AsBounced() (Bounced, error) {
	var body Bounced
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBounced overwrites any union data inside the Command as the provided Bounced
func (t *Command) FromBounced(v Bounced) error {
	v.Cmd = "Bounced"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBounced performs a merge with any union data inside the Command, using the provided Bounced
func (t *Command) MergeBounced(v Bounced) error {
	v.Cmd = "Bounced"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidPacket returns the union data inside the Command as a InvalidPacket
func (t Command) AsInvalidPacket() (InvalidPacket, error) {
	var body InvalidPacket
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidPacket overwrites any union data inside the Command as the provided InvalidPacket
func (t *Command) FromInvalidPacket(v InvalidPacket) error {
	v.Cmd = "InvalidPacket"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidPacket performs a merge with any union data inside the Command, using the provided InvalidPacket
func (t *Command) MergeInvalidPacket(v InvalidPacket) error {
	v.Cmd = "InvalidPacket"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRetrieved returns the union data inside the Command as a Retrieved
func (t Command) AsRetrieved() (Retrieved, error) {
	var body Retrieved
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRetrieved overwrites any union data inside the Command as the provided Retrieved
func (t *Command) FromRetrieved(v Retrieved) error {
	v.Cmd = "Retrieved"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRetrieved performs a merge with any union data inside the Command, using the provided Retrieved
func (t *Command) MergeRetrieved(v Retrieved) error {
	v.Cmd = "Retrieved"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSetReply returns the union data inside the Command as a SetReply
func (t Command) AsSetReply() (SetReply, error) {
	var body SetReply
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSetReply overwrites any union data inside the Command as the provided SetReply
func (t *Command) FromSetReply(v SetReply) error {
	v.Cmd = "SetReply"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSetReply performs a merge with any union data inside the Command, using the provided SetReply
func (t *Command) MergeSetReply(v SetReply) error {
	v.Cmd = "SetReply"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsConnect returns the union data inside the Command as a Connect
func (t Command) AsConnect() (Connect, error) {
	var body Connect
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromConnect overwrites any union data inside the Command as the provided Connect
func (t *Command) FromConnect(v Connect) error {
	v.Cmd = "Connect"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeConnect performs a merge with any union data inside the Command, using the provided Connect
func (t *Command) MergeConnect(v Connect) error {
	v.Cmd = "Connect"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsConnectUpdate returns the union data inside the Command as a ConnectUpdate
func (t Command) AsConnectUpdate() (ConnectUpdate, error) {
	var body ConnectUpdate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromConnectUpdate overwrites any union data inside the Command as the provided ConnectUpdate
func (t *Command) FromConnectUpdate(v ConnectUpdate) error {
	v.Cmd = "ConnectUpdate"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeConnectUpdate performs a merge with any union data inside the Command, using the provided ConnectUpdate
func (t *Command) MergeConnectUpdate(v ConnectUpdate) error {
	v.Cmd = "ConnectUpdate"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSync returns the union data inside the Command as a Sync
func (t Command) AsSync() (Sync, error) {
	var body Sync
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSync overwrites any union data inside the Command as the provided Sync
func (t *Command) FromSync(v Sync) error {
	v.Cmd = "Sync"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSync performs a merge with any union data inside the Command, using the provided Sync
func (t *Command) MergeSync(v Sync) error {
	v.Cmd = "Sync"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsLocationChecks returns the union data inside the Command as a LocationChecks
func (t Command) AsLocationChecks() (LocationChecks, error) {
	var body LocationChecks
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLocationChecks overwrites any union data inside the Command as the provided LocationChecks
func (t *Command) FromLocationChecks(v LocationChecks) error {
	v.Cmd = "LocationChecks"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLocationChecks performs a merge with any union data inside the Command, using the provided LocationChecks
func (t *Command) MergeLocationChecks(v LocationChecks) error {
	v.Cmd = "LocationChecks"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsLocationScouts returns the union data inside the Command as a LocationScouts
func (t Command) AsLocationScouts() (LocationScouts, error) {
	var body LocationScouts
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLocationScouts overwrites any union data inside the Command as the provided LocationScouts
func (t *Command) FromLocationScouts(v LocationScouts) error {
	v.Cmd = "LocationScouts"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLocationScouts performs a merge with any union data inside the Command, using the provided LocationScouts
func (t *Command) MergeLocationScouts(v LocationScouts) error {
	v.Cmd = "LocationScouts"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpdateHint returns the union data inside the Command as a UpdateHint
func (t Command) AsUpdateHint() (UpdateHint, error) {
	var body UpdateHint
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateHint overwrites any union data inside the Command as the provided UpdateHint
func (t *Command) FromUpdateHint(v UpdateHint) error {
	v.Cmd = "UpdateHint"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateHint performs a merge with any union data inside the Command, using the provided UpdateHint
func (t *Command) MergeUpdateHint(v UpdateHint) error {
	v.Cmd = "UpdateHint"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStatusUpdate returns the union data inside the Command as a StatusUpdate
func (t Command) AsStatusUpdate() (StatusUpdate, error) {
	var body StatusUpdate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStatusUpdate overwrites any union data inside the Command as the provided StatusUpdate
func (t *Command) FromStatusUpdate(v StatusUpdate) error {
	v.Cmd = "StatusUpdate"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStatusUpdate performs a merge with any union data inside the Command, using the provided StatusUpdate
func (t *Command) MergeStatusUpdate(v StatusUpdate) error {
	v.Cmd = "StatusUpdate"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSay returns the union data inside the Command as a Say
func (t Command) AsSay() (Say, error) {
	var body Say
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSay overwrites any union data inside the Command as the provided Say
func (t *Command) FromSay(v Say) error {
	v.Cmd = "Say"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSay performs a merge with any union data inside the Command, using the provided Say
func (t *Command) MergeSay(v Say) error {
	v.Cmd = "Say"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGetDataPackage returns the union data inside the Command as a GetDataPackage
func (t Command) AsGetDataPackage() (GetDataPackage, error) {
	var body GetDataPackage
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGetDataPackage overwrites any union data inside the Command as the provided GetDataPackage
func (t *Command) FromGetDataPackage(v GetDataPackage) error {
	v.Cmd = "GetDataPackage"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGetDataPackage performs a merge with any union data inside the Command, using the provided GetDataPackage
func (t *Command) MergeGetDataPackage(v GetDataPackage) error {
	v.Cmd = "GetDataPackage"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBounce returns the union data inside the Command as a Bounce
func (t Command) AsBounce() (Bounce, error) {
	var body Bounce
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBounce overwrites any union data inside the Command as the provided Bounce
func (t *Command) FromBounce(v Bounce) error {
	v.Cmd = "Bounce"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBounce performs a merge with any union data inside the Command, using the provided Bounce
func (t *Command) MergeBounce(v Bounce) error {
	v.Cmd = "Bounce"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGet returns the union data inside the Command as a Get
func (t Command) AsGet() (Get, error) {
	var body Get
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGet overwrites any union data inside the Command as the provided Get
func (t *Command) FromGet(v Get) error {
	v.Cmd = "Get"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGet performs a merge with any union data inside the Command, using the provided Get
func (t *Command) MergeGet(v Get) error {
	v.Cmd = "Get"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSet returns the union data inside the Command as a Set
func (t Command) AsSet() (Set, error) {
	var body Set
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSet overwrites any union data inside the Command as the provided Set
func (t *Command) FromSet(v Set) error {
	v.Cmd = "Set"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSet performs a merge with any union data inside the Command, using the provided Set
func (t *Command) MergeSet(v Set) error {
	v.Cmd = "Set"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSetNotify returns the union data inside the Command as a SetNotify
func (t Command) AsSetNotify() (SetNotify, error) {
	var body SetNotify
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSetNotify overwrites any union data inside the Command as the provided SetNotify
func (t *Command) FromSetNotify(v SetNotify) error {
	v.Cmd = "SetNotify"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSetNotify performs a merge with any union data inside the Command, using the provided SetNotify
func (t *Command) MergeSetNotify(v SetNotify) error {
	v.Cmd = "SetNotify"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Command) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"cmd"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t Command) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "Bounce":
		return t.AsBounce()
	case "Bounced":
		return t.AsBounced()
	case "Connect":
		return t.AsConnect()
	case "ConnectUpdate":
		return t.AsConnectUpdate()
	case "Connected":
		return t.AsConnected()
	case "ConnectionRefused":
		return t.AsConnectionRefused()
	case "DataPackage":
		return t.AsDataPackage()
	case "Get":
		return t.AsGet()
	case "GetDataPackage":
		return t.AsGetDataPackage()
	case "InvalidPacket":
		return t.AsInvalidPacket()
	case "LocationChecks":
		return t.AsLocationChecks()
	case "LocationInfo":
		return t.AsLocationInfo()
	case "LocationScouts":
		return t.AsLocationScouts()
	case "PrintJSON":
		return t.AsPrintJSON()
	case "ReceivedItems":
		return t.AsReceivedItems()
	case "Retrieved":
		return t.AsRetrieved()
	case "RoomInfo":
		return t.AsRoomInfo()
	case "RoomUpdate":
		return t.AsRoomUpdate()
	case "Say":
		return t.AsSay()
	case "Set":
		return t.AsSet()
	case "SetNotify":
		return t.AsSetNotify()
	case "SetReply":
		return t.AsSetReply()
	case "StatusUpdate":
		return t.AsStatusUpdate()
	case "Sync":
		return t.AsSync()
	case "UpdateHint":
		return t.AsUpdateHint()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t Command) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Command) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}
